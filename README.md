The repo has random tools for automation testing

Few other unrelated useful tips:
Steps to set-up eclipse debugging through jumpbox : 
  1. Start the application in debug mode on your desired port (this process varies for different kinds of servers, tomcat is different from jboss and stuff)
  1. We create a tunnel from the local machine to the jump box: sudo ssh -i ~/localkey -Nf -L 8005:localhost:8005 aws_user@aws_ec2_host_ip
  Here we create a tunnel from 8005 on local host to 8005 on the jump box (http://blog.seyfi.net/2016/06/how-to-remotely-debug-java-applications.html)
  2. Then we create a tunnel from the jumpbox to the node that the service is hosted on using the same command except changing the machine name and pem file.
  3. We then start a remote debug on our eclipse on port 8005 (the port configured in the first)
  
 Sources: https://stackoverflow.com/questions/20658984/remote-debugging-eclipse-via-jump-host
 http://blog.seyfi.net/2016/06/how-to-remotely-debug-java-applications.html

SSL Notes:
SSL Knowledge basics:
1. SSL Keys are encryption and decryption: 2 Types of decryption are Symmetric and non-symmetric, symmetric means same key is used for encryption and decryption. non-symmetric is when different keys are used to encrypt and decrypt (encrypter key cannot be used to decrypt), the PKI (Public Key Infrastructure) in which the public key is distributed, the problem with non-symmetric decryption is that the keys are large (2048 Bytes) and so the encryption decryption is slow while the symmetric decryption is fast. To get around the server provides its public key to the client, the client now transfers the symmetric key that it has to the server encrypted using the public key the server gave (this symmetric key is now NOT decryptable by the public key, only the private key can decrypt it). The server then decrypts the symmetric key and then communication happens symmetrically (which is faster, the only slow encryption is when the symmetric key is exchanged). The catch here is that the symmetric key exchanged must be different for every session established between client and server
2. Certificates are exchanged when an SSL Connection is established between a client and a server. The certificates contain the server's identity and a public key for further communication. Certificates are generated and validated (when certificates are exchanged during connection establish) by a certificate authority which is a provider not affiliated with the Server/Company. Self-signed certificates are certificates that are generated by the company itself, they are not validated by Certificate Authorities since they are not generated by them, we need self-signed certificates for SSL Communication internally.
3. Process of how Server/Company obtains Certificate: Server has to generate public and private key, server sends its identification details along with its generated public key (private key is NOT sent) to a certificate authority org (such as entrust) the org provides the server/company with a certificate that has its public key, its identification and the certificate authority's identification back to the company, the command to run this is called the CSR (Certificate Signing Request). The Certificate Signing Request is made using a program called OpenSSL that is available on all major web servers (such as Apache).
4. The self-signed certificate works for intents and purposes but there isn't a confirmation on whether the certificate received by the client is indeed from the server it intends to connect to. Means, the client connects to an IP Address, the IP Address returns a certificate, the certificate has the public key, the client encrypts content being sent to this IP Address using this public key, though the content is encrypted, it may be being sent to an imposter who provides a non-certifiable identity, to get around this we have in-house certificate authorities. A in-house certificate authority creates a "root" certificate (a "root" essentially represents a custom certificate authority), every time a node receives a certificate from another in your internal network, the node then validates the server's identity with the in-house CA root certificate (which needs to be available in every node on the server)
